# This file is part of ip_isr.
#
# Developed for the LSST Data Management System.
# This product includes software developed by the LSST Project
# (https://www.lsst.org).
# See the COPYRIGHT file at the top-level directory of this distribution
# for details of code ownership.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
"""Brighter Fatter Kernel calibration definition."""


__all__ = ['BrighterFatterKernel']


import numpy as np
from collections import defaultdict
from astropy.table import Table
from . import IsrCalib


class BrighterFatterKernel(IsrCalib):
    """Calibration of brighter-fatter kernels for an instrument.

    ampKernels are the kernels for each amplifier in a detector, as
    generated by having level == 'AMP'

    detectorKernel is the kernel generated for a detector as a
    whole, as generated by having level == 'DETECTOR'

    makeDetectorKernelFromAmpwiseKernels is a method to generate the
    kernel for a detector, constructed by averaging together the
    ampwise kernels in the detector.

    The sourceLevel is the level for which the kernel(s) were
    generated, i.e. the level at which the task was originally run.

    Parameters
    ----------
    level : `str`
        Level the kernels will be generated for.
    log : `lsst.log.Log`, optional
        Log to write messages to.
    **kwargs :
        Parameters to pass to parent constructor.

    """
    _OBSTYPE = 'BFK'
    _SCHEMA = 'Gen3 brighter-fatter kernel'
    _VERSION = 1.0

    def __init__(self, camera=None, level=None, **kwargs):
        self.level = level
        self.sourceLevel = level

        # Internal archival information?
        self.originalLevel = self.sourceLevel
        self.means = None
        self.rawMeans = None
        self.rawXcorrs = None
        self.xCorrs = None
        self.meanXCorrs = None

        # Things directly from PTCdata
        self.gain = None
        self.gainErr = None
        self.noise = None
        self.noseErr = None
        self.ptcResults = None

        # Things that are used downstream
        if camera:
            self.initFromCamera(camera)

        self.gains = defaultdict(dict)
        self.ampKernels = defaultdict(dict)
        self.detKernels = dict()

        super().__init__(**kwargs)
        self.requiredAttributes.update(['level', 'gains',
                                        'ampKernels', 'detKernels'])

    def updateMetadata(self, setDate=False, **kwargs):
        """Update calibration metadata.

        This calls the base class's method after ensuring the required
        calibration keywords will be saved.

        Parameters
        ----------
        setDate : `bool`, optional
            Update the CALIBDATE fields in the metadata to the current
            time. Defaults to False.
        kwargs :
            Other keyword parameters to set in the metadata.
        """
        kwargs['INSTRUME'] = self._instrument

        super().updateMetadata(setDate=setDate, **kwargs)

    def initFromCamera(self, camera):
        """Initialize kernel structure from camera.

        Parameters
        ----------
        camera : `lsst.afw.cameraGeom.Camera`
            Camera to use to define geometry.

        Returns
        -------
        calib : `lsst.ip.isr.BrighterFatterKernel`
            The initialized calibration.
        """
        self._instrument = camera.getName()
        for det in camera:
            detName = det.getName()
            self.detKernels[detName] = []

            for amp in det:
                ampName = amp.getName()
                self.gains[detName][ampName] = []
                self.ampKernels[detName][ampName] = []
        return self

    @classmethod
    def fromDict(cls, dictionary):
        """Construct a calibration from a dictionary of properties.

        Parameters
        ----------
        dictionary : `dict`
            Dictionary of properties.

        Returns
        -------
        calib : `lsst.ip.isr.BrighterFatterKernel
            Constructed calibration.

        Raises
        ------
        RuntimeError :
            Raised if the supplied dictionary is for a different
            calibration.
        """
        calib = cls()

        if calib._OBSTYPE != dictionary['metadata']['OBSTYPE']:
            raise RuntimeError(f"Incorrect brighter-fatter kernel supplied.  Expected {calib._OBSTYPE}, "
                               f"found {dictionary['metadata']['OBSTYPE']}")

        calib.setMetadata(dictionary['metadata'])
        calib._instrument = dictionary['metadata']['INSTRUME']
        calib.level = dictionary['metadata']['LEVEL']
        calib.sourceLevel = dictionary['metadata']['SOURCE_LEVEL']
        calib.shape = (dictionary['metadata']['KERNEL_DX'],
                       dictionary['metadata']['KERNEL_DY'])

        calib.gains = dictionary['gains']
        calib.ampKernels = {amp: dictionary['ampKernels'][amp].reshape(calib.shape)
                            for amp in dictionary['ampKernels']}
        calib.detKernels = {det: dictionary['detKernels'][det].reshape(calib.shape)
                            for det in dictionary['detKernels']}

        calib.updateMetadata()
        return calib

    def toDict(self):
        """Return a dictionary containing the calibration properties.

        The dictionary should be able to be round-tripped through
        `fromDict`.

        Returns
        -------
        dictionary : `dict`
            Dictionary of properties.
        """
        self.updateMetadata(LEVEL=self.level, SOURCE_LEVEL=self.sourceLevel)

        outDict = {}
        metadata = self.getMetadata()
        outDict['metadata'] = metadata

        kernelLength = self.shape[0] * self.shape[1]

        outDict['gains'] = self.gains
        outDict['ampKernels'] = {amp: self.ampKernels[amp].reshape(kernelLength).tolist()
                                 for amp in self.ampKernels}
        outDict['detKernels'] = {det: self.detKernels[det].reshape(kernelLength).tolist()
                                 for det in self.detKernels}

        return outDict

    @classmethod
    def fromTable(cls, tableList):
        """Construct calibration from a list of tables.

        This method uses the `fromDict` method to create the
        calibration, after constructing an appropriate dictionary from
        the input tables.

        Parameters
        ----------
        tableList : `list` [`astropy.table.Table`]
            List of tables to use to construct the brighter-fatter
            calibration.

        Returns
        -------
        calib : `lsst.ip.isr.BrighterFatterKernel`
            The calibration defined in the tables.
        """
        ampTable = tableList[0]

        metadata = ampTable.meta
        inDict = dict()
        inDict['metadata'] = metadata

        inDict['instrument'] = metadata['INSTRUME']
        inDict['level'] = metadata['LEVEL']
        inDict['sourceLevel'] = metadata['SOURCE_LEVEL']

        amps = ampTable['AMPLIFIER']
        gains = ampTable['GAIN']
        ampKernels = ampTable['KERNEL']

        inDict['gains'] = {amp: gain for amp, gain in zip(amps, gains)}
        inDict['ampKernels'] = {amp: kernel for amp, kernel in zip(amps, ampKernels)}

        if len(tableList) > 1:
            detTable = tableList[1]
            inDict['detKernels'] = {det: kernel for det, kernel
                                    in zip(detTable['DETECTOR'], detTable['KERNEL'])}

        return cls.fromDict(inDict)

    def toTable(self):
        """Construct a list of tables containing the information in this calibration.

        The list of tables should create an identical calibration
        after being passed to this class's fromTable method.

        Returns
        -------
        tableList : `list` [`lsst.afw.table.Table`]
            List of tables containing the crosstalk calibration
            information.

        """
        tableList = []
        self.updateMetadata()
        kernelLength = self.shape[0] * self.shape[1]

        ampTable = Table([{'AMPLIFIER': self.gains.keys(),
                           'GAIN': self.gains,
                           'KERNEL': [self.ampKernels[amp].reshape(kernelLength).toList()
                                      for amp in self.gains]}])
        ampTable.meta = self.getMetadata().toDict()
        tableList.append(ampTable)

        detTable = Table([{'DETECTOR': self.detKernel.keys(),
                           'KERNEL': [self.detKernels[det].reshape(kernelLength).toList()
                                      for det in self.detKernels]}])
        detTable.meta = self.getMetadata().toDict()
        tableList.append(detTable)

        return tableList

    # Implementation methods
    def makeDetectorKernelFromAmpwiseKernels(self, detectorName, ampsToExclude=[]):
        """Average the amplifier level kernels to create a detector level kernel.
        """
        inKernels = [self.ampKernels[detectorName][amp] for amp in
                     self.ampKernels[detectorName] if amp not in ampsToExclude]
        avgKernel = np.zeros_like(inKernels[0])
        for kernel in inKernels:
            avgKernel += kernel
        avgKernel /= len(inKernels)

        self.detKernels[detectorName] = avgKernel

    def replaceDetectorKernelWithAmpKernel(self, ampName, detectorName):
        self.detKernel[detectorName] = self.ampKernel[ampName]
