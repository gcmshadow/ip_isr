# This file is part of ip_isr.
#
# Developed for the LSST Data Management System.
# This product includes software developed by the LSST Project
# (https://www.lsst.org).
# See the COPYRIGHT file at the top-level directory of this distribution
# for details of code ownership.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
"""Brighter Fatter Kernel calibration definition."""


__all__ = ['BrighterFatterKernel']


import numpy as np
from astropy.table import Table
from . import IsrCalib


class BrighterFatterKernel(IsrCalib):
    """Calibration of brighter-fatter kernels for an instrument.

    ampKernels are the kernels for each amplifier in a detector, as
    generated by having level == 'AMP'

    detectorKernel is the kernel generated for a detector as a
    whole, as generated by having level == 'DETECTOR'

    makeDetectorKernelFromAmpwiseKernels is a method to generate the
    kernel for a detector, constructed by averaging together the
    ampwise kernels in the detector.

    The sourceLevel is the level for which the kernel(s) were
    generated, i.e. the level at which the task was originally run.

    Parameters
    ----------
    level : `str`
        Level the kernels will be generated for.
    log : `lsst.log.Log`, optional
        Log to write messages to.
    **kwargs :
        Parameters to pass to parent constructor.

    """
    _OBSTYPE = 'BFK'
    _SCHEMA = 'Gen3 brighter-fatter kernel'
    _VERSION = 1.0

    def __init__(self, camera=None, level=None, **kwargs):
        self.level = level
        self.sourceLevel = level

        # CZW: These two blocks are unnecessary, correct?
        # Internal archival information?
        self.originalLevel = self.sourceLevel
        self.means = None
        self.rawMeans = dict()
        self.rawXCorrs = dict()
        self.xCorrs = dict()
        self.meanXCorrs = dict()

        # Things directly from PTCdata
        self.gain = dict()
        self.gainErr = None
        self.noise = None
        self.noseErr = None
        self.ptcResults = None

        # PTC Contents:
        # rawMeans / rawVars
        # gain / gainErr / noise /noiseErr
        # p tcFitPars / ptcFitsParsError / ptcFitChiSq
        # covariances / covariancesModel / covariancesSqrtWeights
        # aMatrix / bMatrix / covariancesNoB / covarModelNoB / covarSqrtWgtNoB / aMatrixNoB
        # finalVars / finalModelVars / finalMeans

        # Things that are used downstream

        self.ampKernels = dict()
        self.detKernels = dict()
        self.shape = (8, 8)

        if camera:
            self.initFromCamera(camera, detectorId=kwargs.get('detectorId', None))

        super().__init__(**kwargs)
        self.requiredAttributes.update(['level', 'sourceLevel', 'gain',
                                        'ampKernels', 'detKernels'])

    def updateMetadata(self, setDate=False, **kwargs):
        """Update calibration metadata.

        This calls the base class's method after ensuring the required
        calibration keywords will be saved.

        Parameters
        ----------
        setDate : `bool`, optional
            Update the CALIBDATE fields in the metadata to the current
            time. Defaults to False.
        kwargs :
            Other keyword parameters to set in the metadata.
        """
        kwargs['LEVEL'] = self.level
        kwargs['SOURCE_LEVEL'] = self.sourceLevel
        kwargs['KERNEL_DX'] = self.shape[0]
        kwargs['KERNEL_DY'] = self.shape[1]

        super().updateMetadata(setDate=setDate, **kwargs)

    def initFromCamera(self, camera, detectorId=None):
        """Initialize kernel structure from camera.

        Parameters
        ----------
        camera : `lsst.afw.cameraGeom.Camera`
            Camera to use to define geometry.
        detectorId : `int`, optional
            Index of the detector to generate.

        Returns
        -------
        calib : `lsst.ip.isr.BrighterFatterKernel`
            The initialized calibration.
        """
        self._instrument = camera.getName()

        if self.level == 'AMP':
            detector = camera[detectorId]
            self._detectorId = detectorId
            self._detectorName = detector.getName()
            self._detectorSerial = detector.getSerial()

            for amp in detector:
                ampName = amp.getName()
                self.gain[ampName] = []
                self.ampKernels[ampName] = []
        elif self.level == 'DETECTOR':
            for det in camera:
                detName = det.getName()
                self.detKernels[detName] = []

        return self

    @classmethod
    def fromDict(cls, dictionary):
        """Construct a calibration from a dictionary of properties.

        Parameters
        ----------
        dictionary : `dict`
            Dictionary of properties.

        Returns
        -------
        calib : `lsst.ip.isr.BrighterFatterKernel
            Constructed calibration.

        Raises
        ------
        RuntimeError :
            Raised if the supplied dictionary is for a different
            calibration.
        """
        calib = cls()

        if calib._OBSTYPE != dictionary['metadata']['OBSTYPE']:
            raise RuntimeError(f"Incorrect brighter-fatter kernel supplied.  Expected {calib._OBSTYPE}, "
                               f"found {dictionary['metadata']['OBSTYPE']}")

        calib.setMetadata(dictionary['metadata'])
        calib.calibInfoFromDict(dictionary)

        calib.level = dictionary['metadata'].get('LEVEL', 'AMP')
        calib.sourceLevel = dictionary['metadata'].get('SOURCE_LEVEL', 'AMP')
        calib.shape = (dictionary['metadata'].get('KERNEL_DX', 0),
                       dictionary['metadata'].get('KERNEL_DY', 0))

        calib.gain = dictionary['gain']
        calib.rawMeans = {amp: dictionary['rawMeans'][amp] for amp in dictionary['rawMeans']}
        calib.rawXcorrs = {amp: dictionary['rawXcorrs'][amp] for amp in dictionary['rawXcorrs']}
        calib.xCorrs = {amp: dictionary['xCorrs'][amp] for amp in dictionary['xCorrs']}
        calib.meanXCorrs = {amp: dictionary['meanXcorrs'][amp] for amp in dictionary['rawXcorrs']}

        calib.ampKernels = {amp: np.array(dictionary['ampKernels'][amp]).reshape(calib.shape)
                            for amp in dictionary['ampKernels']}
        calib.detKernels = {det: np.array(dictionary['detKernels'][det]).reshape(calib.shape)
                            for det in dictionary['detKernels']}


        calib.updateMetadata()
        return calib

    def toDict(self):
        """Return a dictionary containing the calibration properties.

        The dictionary should be able to be round-tripped through
        `fromDict`.

        Returns
        -------
        dictionary : `dict`
            Dictionary of properties.
        """
        self.updateMetadata()

        outDict = {}
        metadata = self.getMetadata()
        outDict['metadata'] = metadata

        kernelLength = self.shape[0] * self.shape[1]

        outDict['gain'] = self.gain
        outDict['ampKernels'] = {amp: self.ampKernels[amp].reshape(kernelLength).tolist()
                                 for amp in self.ampKernels}
        outDict['detKernels'] = {det: self.detKernels[det].reshape(kernelLength).tolist()
                                 for det in self.detKernels}
        outDict['rawMeans'] = {amp: self.rawMeans[amp] for amp in self.rawMeans}
        outDict['rawXcorrs'] = {amp: self.rawXcorrs[amp] for amp in self.rawXcorrs}
        outDict['xCorrs'] = {amp: self.xCorrs[amp].tolist() for amp in self.xCorrs}
        outDict['meanXcorrs'] = {amp: self.meanXCorrs[amp].tolist() for amp in self.meanXCorrs}

        return outDict

    @classmethod
    def fromTable(cls, tableList):
        """Construct calibration from a list of tables.

        This method uses the `fromDict` method to create the
        calibration, after constructing an appropriate dictionary from
        the input tables.

        Parameters
        ----------
        tableList : `list` [`astropy.table.Table`]
            List of tables to use to construct the brighter-fatter
            calibration.

        Returns
        -------
        calib : `lsst.ip.isr.BrighterFatterKernel`
            The calibration defined in the tables.
        """
        ampTable = tableList[0]

        metadata = ampTable.meta
        inDict = dict()
        inDict['metadata'] = metadata

        amps = ampTable['AMPLIFIER']
        gainList = ampTable['GAIN']
        ampKernels = ampTable['KERNEL']

        rawMeans = ampTable['RAW_MEANS']
        rawXcorrs = ampTable['RAW_XCORRS']
        xCorrs = ampTable['XCORRS']
        meanXcorrs = ampTable['MEAN_XCORRS']

        inDict['gain'] = {amp: gain for amp, gain in zip(amps, gainList)}
        inDict['ampKernels'] = {amp: kernel for amp, kernel in zip(amps, ampKernels)}

        inDict['rawMeans'] = {amp: kernel for amp, kernel in zip(amps, rawMeans)}
        inDict['rawXcorrs'] = {amp: kernel for amp, kernel in zip(amps, rawXcorrs)}
        inDict['xCorrs'] = {amp: kernel for amp, kernel in zip(amps, xCorrs)}
        inDict['meanXcorrs'] = {amp: kernel for amp, kernel in zip(amps, meanXcorrs)}

        if len(tableList) > 1:
            detTable = tableList[1]
            inDict['detKernels'] = {det: kernel for det, kernel
                                    in zip(detTable['DETECTOR'], detTable['KERNEL'])}
        else:
            inDict['detKernels'] = {}

        return cls.fromDict(inDict)

    def toTable(self):
        """Construct a list of tables containing the information in this calibration.

        The list of tables should create an identical calibration
        after being passed to this class's fromTable method.

        Returns
        -------
        tableList : `list` [`lsst.afw.table.Table`]
            List of tables containing the crosstalk calibration
            information.

        """
        tableList = []
        self.updateMetadata()
        kernelLength = self.shape[0] * self.shape[1]

        ampList = []
        gainList = []
        kernelList = []

        rawMeanList = []
        rawXcorrList = []
        xCorrList = []
        meanXcorrsList = []

        for amp in self.gain.keys():
            ampList.append(amp)
            gainList.append(self.gain[amp])
            kernelList.append(self.ampKernels[amp].reshape(kernelLength).tolist())

        ampTable = Table({'AMPLIFIER': ampList,
                          'GAIN': gainList,
                          'KERNEL': kernelList,
                          'RAW_MEANS': rawMeanList,
                          'RAW_XCORRS': rawXcorrList,
                          'XCORRS': xCorrList,
                          'MEAN_XCORRS': meanXcorrsList,
                      })
        ampTable.meta = self.getMetadata().toDict()
        tableList.append(ampTable)

        if False:
            detList = []
            kernelList = []
            for det in self.detKernels.keys():
                detList.append(det)
                kernelList.append(self.detKernels[det].reshape(kernelLength).tolist())

            detTable = Table({'DETECTOR': detList,
                              'KERNEL': kernelList})
            detTable.meta = self.getMetadata().toDict()
            tableList.append(detTable)

        return tableList

    # Implementation methods
    def makeDetectorKernelFromAmpwiseKernels(self, detectorName, ampsToExclude=[]):
        """Average the amplifier level kernels to create a detector level kernel.
        """
        inKernels = [self.ampKernels[amp] for amp in
                     self.ampKernels if amp not in ampsToExclude]
        avgKernel = np.zeros_like(inKernels[0])
        for kernel in inKernels:
            avgKernel += kernel
        avgKernel /= len(inKernels)

        self.detKernels[detectorName] = avgKernel

    def replaceDetectorKernelWithAmpKernel(self, ampName, detectorName):
        self.detKernel[detectorName] = self.ampKernel[ampName]
